#!/usr/bin/env python
#
"""
	Erlang-transmission daemon control
	
	@author Jean-Lou Dupont
"""
import os
import sys
import subprocess
from optparse import OptionParser

class Commands(object):
	
	cmdStart  = "erl -pa %s -detached -sname transmission -run transmission_daemon start"
	cmdStop   = "escript etrx_control -q stop"
	cmdStatus = "escript etrx_control -q status"	
	
	dostart  = "starting daemon"
	nodaemon = "cannot start daemon"
	nostop   = "cannot stop daemon"
	canstop  = "ok"
	
	codes = {	0: {"msg":"ok",                "canstart": True,  "stop":canstop, "start":dostart  },
				1: {"msg":"unspecified error", "canstart": True,  "stop":nostop,  "start":dostart  }, 
				2: {"msg":"daemon found",      "canstart": False, "stop":nostop,  "start":nodaemon }, 
				3: {"msg":"daemon not found",  "canstart": True,  "stop":nostop,  "start":dostart  }, 
				4: {"msg":"library not found", "canstart": False, "stop":nostop,  "start":nodaemon },
				5: {"msg":"node not found",    "canstart": True,  "stop":nostop,  "start":dostart  },
			}
	
	def cmd_start(self, fb):
		ctx=self._canStart()
		if fb:
			print "etrx: %s [%s]\n" % (ctx["start"], ctx["msg"])
		if not ctx["canstart"]:
			sys.exit(1)

		self._dostart()
		sys.exit(0)	
		
	def cmd_stop(self, feedback):
		self._dostop(feedback)
	
	def _dostart(self):
	
		#add development path
		cwd=os.getcwd()
		cmd=self.cmdStart % (cwd+"/ebin")
		proc = subprocess.Popen(cmd, shell=True)
		return proc.wait()
		
	def _dostop(self, fb):
		proc = subprocess.Popen(self.cmdStop, shell=True)
		proc.wait()
		ret=proc.returncode
		ctx=self._getCtx(ret)
		if fb:
			print "etrx: %s [%s]\n" % (ctx["stop"], ctx["msg"])

	def _getCtx(self, code):
		ctx=self.codes.get(code, self.codes[1])
		return ctx			

	def _canStart(self):
		proc = subprocess.Popen(self.cmdStatus, shell=True)
		proc.wait()
		ret=proc.returncode
		ctx=self._getCtx(ret)
		return ctx
		
	

def main():
	usage= """etrx [-q] [start|stop] 
"""
	
	parser=OptionParser(usage)
	parser.add_option("-q", "--quiet",
                  action="store_false", dest="feedback", default=True,
                  help="don't print status messages to stdout")
                  
	(options, args) = parser.parse_args()
    
	if len(args) != 1:
		parser.error("incorrect number of arguments")
      
	cmd = args[0]
	feedback = options.feedback
	
	try:
		getattr(Commands(), "cmd_"+cmd)(feedback)
	except Exception, e:
		##print "Exception [%s]\n" % e
		print "! invalid command [%s]\n" % cmd

	
if __name__=="__main__":
	main()
